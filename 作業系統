作業系統重點
 

ALU（算术逻辑单元）和 GPU（图形处理单元）是计算机体系结构中的两个不同的组件，它们在功能和设计上有很大的区别。
1.	ALU（算术逻辑单元）：
•	定义： ALU是中央处理单元（CPU）中的一个核心组件，负责执行算术和逻辑运算。它执行诸如加法、减法、逻辑与、逻辑或等基本算术和逻辑运算。
•	用途： ALU主要用于执行计算任务，处理整数和浮点数的基本运算。它是CPU中的关键组件，执行大多数指令。
2.	GPU（图形处理单元）：
•	定义： GPU是专门设计用于图形处理和并行计算的处理器。它包含大量的小处理单元，用于同时处理大量数据，尤其是在图形渲染和科学计算中。
•	用途： GPU的主要用途是加速图形处理，例如在游戏、计算机辅助设计（CAD）和视频渲染中。除此之外，由于其并行处理能力，GPU也被广泛用于科学计算和深度学习等领域。
比较：
•	设计目标： ALU的设计目标是执行通用的算术和逻辑运算，而GPU的设计目标是加速图形渲染和并行计算。
•	并行性： GPU在设计上强调大规模并行性，具有多个处理单元，可以同时处理多个数据。ALU通常更专注于单一任务的执行。
•	数据处理： ALU主要处理通用的整数和浮点数计算，而GPU在图形处理中更专注于向量和矩阵运算，以及在并行计算中执行大规模的浮点数操作。
•	用途： ALU是CPU的一部分，用于执行程序中的通用计算任务。GPU则专注于图形渲染和并行计算，适用于需要大规模并行性的应用。
 



控制单元（Control Unit）是计算机中的一个核心组件，属于中央处理单元（CPU）的一部分。它负责协调和控制CPU内部各个部件的操作，以及执行指令的顺序。控制单元的主要功能是从存储器中读取指令、解码指令并执行对应的操作，以使计算机能够完成所需的任务。
主要职责和功能包括：
1.	指令获取（Instruction Fetch）： 控制单元从内存中获取存储在程序计数器指定位置的指令。
2.	指令解码（Instruction Decode）： 控制单元对获取的指令进行解码，确定该指令要执行的操作。
3.	执行操作（Execution）： 控制单元根据解码的指令执行相应的操作，可能涉及到算术和逻辑运算、数据传输等。
4.	时序控制（Timing Control）： 控制单元确保各个操作在正确的时间序列中执行，以保证计算机的稳定运行。
5.	分支控制（Branch Control）： 处理条件分支和无条件分支指令，决定程序计数器的跳转。
6.	异常处理（Exception Handling）： 处理中断和异常，确保在出现特殊情况时能够适当地转移控制。
7.	状态维护（State Maintenance）： 控制单元维护CPU内部状态的正确性，包括标志寄存器和其他状态信息。
控制单元与算术逻辑单元（ALU）一起协同工作，以执行指令中的操作。控制单元的设计取决于计算机体系结构，不同的体系结构可能有不同的指令集和控制单元结构。它是计算机执行程序的关键部分，确保指令按照正确的顺序和时序执行，从而实现计算和数据处理。

CPU执行周期包括以下阶段：
1.	取指令阶段（Fetch）： 从内存中取得下一条机器指令。
2.	指令解码阶段（Decode）： 对取得的指令进行解码，确定需要执行的操作。
3.	执行阶段（Execute）： 执行指令中的操作，可能涉及算术运算、逻辑运算等。
4.	访存阶段（Memory Access）： 如果指令需要访问内存，则在此阶段进行内存读取或写入操作。
5.	写回阶段（Write Back）： 将执行结果写回到寄存器或内存。

………………………………………………………………..
Batch system
Multiprogramming
Time sharing
Multiprocessing
Distributed sys
Real time sys
Handheld sys


多元程式規劃
Offline
Buffering(cpu bond job /io bond job)
Spooling
Caching


i/o處理方式
polling io
interrupt io
DMA

硬體保護
Io保護
Memory保護(monitor area protection/user program area protection)
Cpu保護

作業系統接收訊息
命令直譯器
系統呼叫(sys call)

Kernel

vm


行程
Program vs process

行程狀態

行程控制表

排班佇列:
工作佇列
就緒佇列
裝置佇列

排班佇列種類
長期排班程式
短程排班程式
中期排班程式

Cpu scheduling algo(說明優缺比較)
CPU调度的主要目的是有效地利用CPU资源，提高系统的性能和响应时间。以下是CPU调度的一些主要目的：
1.	提高CPU利用率： CPU调度的核心目标之一是确保CPU尽可能地保持忙碌，避免因某些进程等待而导致CPU空闲。通过选择合适的进程来执行，系统可以更充分地利用CPU资源。
2.	减少等待时间： CPU调度致力于减少进程等待CPU执行的时间，以提高系统的响应时间。选择高优先级的进程或采用其他调度算法，可以降低进程等待CPU的时间，使系统更加敏捷。
3.	提高系统吞吐量： 通过合理调度进程，系统可以达到更高的吞吐量，即在单位时间内完成的进程数量。有效的调度算法可以确保系统同时执行多个进程，从而提高整体系统性能。
4.	公平性： CPU调度还追求公平性，确保每个进程都有机会获得CPU时间。公平的调度可以防止某个进程长时间占用CPU资源，导致其他进程无法得到执行的情况。
5.	避免饥饿和死锁： CPU调度要避免进程因资源不足而陷入饥饿状态，确保所有进程都有机会执行。此外，一些调度算法还可以帮助预防死锁的发生。
6.	响应时间优化： 对于交互式系统，即时响应对用户体验至关重要。CPU调度可以通过合理选择进程，使得对用户输入的响应更为迅速。
7.	先来先服务（First-Come, First-Served，FCFS）：
1.	描述： 按照进程到达就绪队列的顺序进行调度。先到达的进程先被执行。
2.	优点： 简单，易于实现。
3.	缺点： 长作业可能导致短作业等待时间过长（"Convoy Effect"），无法适应不同作业的执行时间差异。
8.	最短作业优先（Shortest Job Next，SJN）或最短作业优先（Shortest Job First，SJF）：
1.	描述： 选择下一个执行的进程时，选择估计执行时间最短的进程。
2.	优点： 最小化平均等待时间，适用于批处理系统。
3.	缺点： 无法预知作业的实际执行时间，可能导致长作业一直等待。
9.	轮转调度（Round Robin，RR）：
1.	描述： 每个进程被分配一个时间片（时间量），当时间片用完后，切换到下一个就绪队列中的进程。
2.	优点： 公平，适用于分时系统。
3.	缺点： 可能导致上下文切换开销过大，响应时间相对较长。
10.	优先级调度：
1.	描述： 给每个进程分配一个优先级，选择下一个执行的进程时，选择具有最高优先级的进程。
2.	优点： 可以根据任务的重要性分配优先级。
3.	缺点： 可能导致低优先级的进程长时间等待，优先级反转问题。
11.	多级反馈队列调度（Multilevel Feedback Queue，MLFQ）：
1.	描述： 将就绪队列划分为多个级别，每个级别具有不同的优先级，进程根据其行为在不同队列中移动。
2.	优点： 适应性强，能够处理不同类型的进程。
3.	缺点： 调整参数需要谨慎，复杂度较高。
12.	短作业剩余时间优先（Shortest Remaining Job First，SRJF）：
1.	描述： 在每次选择下一个执行的进程时，选择剩余执行时间最短的进程。
2.	优点： 有效地减小平均等待时间，对批处理系统有良好的性能。
3.	缺点： 需要预测进程的剩余执行时间，可能导致长作业一直等待。
13.	多级队列调度（Multilevel Queue Scheduling）：
1.	描述： 将就绪队列划分为多个独立的队列，每个队列具有不同的优先级。通常，较高优先级队列的进程先执行，如果队列为空，则执行较低优先级队列中的进程。
2.	优点： 简单、灵活，适应性强，可以根据进程的属性分配到不同队列。
3.	缺点： 不够灵活，可能导致长时间等待高优先级队列的进程。
 

"Starvation"（饥饿）问题通常出现在某些特定的调度算法或策略中，导致某些进程或任务无法获得执行的机会。以下是一些可能导致饥饿问题的调度方法和一些不容易导致饥饿的方法：
有可能导致饥饿的调度方法：
1.	优先级调度： 如果所有进程都具有较高优先级的进程存在，低优先级的进程可能长时间等待，导致饥饿问题。这种情况下，高优先级的进程会占据CPU，而低优先级的进程得不到执行机会。
2.	多级队列调度（MLFQ）： 如果有大量的进程在高优先级队列中，而低优先级队列中的进程一直无法获得执行机会，也可能导致饥饿。这可能发生在系统调整队列切换的策略不当的情况下。
不容易导致饥饿的调度方法：
1.	先来先服务（FCFS）： FCFS 调度方法通常是公平的，每个进程都按照它们到达就绪队列的顺序执行。但是，如果有长作业占据CPU，其他进程可能需要长时间等待。
2.	轮转调度（RR）： 轮转调度会给每个进程分配一个时间片，确保每个进程都有机会执行。虽然可能存在等待时间较长的问题，但不容易导致饥饿，因为每个进程都会轮流执行。
3.	多级反馈队列调度（MLFQ）的合理实现： 在合理设置队列切换的条件和时间片的情况下，MLFQ 调度也可以避免饥饿问题。


Thread
Thread vs process
1.	程序（Program）：
•	定义： 程序是一组指令和数据的集合，是静态的，未执行的代码文件。
•	生命周期： 程序存在于磁盘或其他存储媒体上，直到被加载到内存并执行为止。
2.	进程（Process）：
•	定义： 进程是正在运行的程序的实例，包括执行时所需的指令、数据、和系统资源。
•	生命周期： 进程具有动态的生命周期，包括创建、执行、终止等阶段。
3.	线程（Thread）：
•	定义： 线程是在进程内执行的独立执行单元，共享进程的资源，包括内存和文件句柄等。
•	生命周期： 线程的生命周期依赖于所属的进程，多个线程可以共享相同的资源。
 

Thread種類
Thread pool







Deadlock
1.	死锁（Deadlock）：
•	定义： 死锁是指两个或多个线程或进程彼此等待对方释放资源，而导致所有线程或进程都无法继续执行的状态。
•	典型情景： 常见于多个线程或进程同时持有某些资源，并且试图获取其他线程或进程持有的资源。如果没有适当的资源释放机制或资源请求的顺序导致循环等待，可能发生死锁。
2.	活锁（Livelock）：
•	定义： 活锁是指线程或进程在避免死锁的过程中，由于不断重试导致一直无法取得进展的状态。
•	典型情景： 当多个线程或进程试图解决冲突或争夺资源时，它们可能会不断重试，但由于竞争条件或争夺的资源一直不可用，它们无法继续执行，形成了活锁。
关键区别：
•	死锁是线程或进程等待彼此释放资源的状态，导致所有线程或进程无法继续执行。
•	活锁是线程或进程在解决冲突或竞争资源时，由于不断重试而无法取得进展。
 cp
達成條件
處理方式

記憶體管理
Memory allocation strategy:
First fit
Best fit
Worst fit
Next fit
常發生的問題與解決方式


虛擬記憶體(vm)
1.	Virtual Memory (虚拟内存):
•	定义： 虚拟内存是一种操作系统的内存管理技术，允许程序访问一个比实际物理内存更大的地址空间。它通过将部分数据存储到硬盘上，以便在需要时进行交换，从而扩展了计算机的可用内存。在虚拟内存系统中，每个进程都有其私有的虚拟地址空间，而不受物理内存的限制。
•	用途： 虚拟内存的主要目的是提供更大的地址空间，使得多个进程能够共存，并且在需要时能够有效地使用磁盘作为辅助存储。
2.	Virtual Machine (虚拟机):
•	定义： 虚拟机是一种在计算机上模拟硬件和操作系统的软件实体。它提供了一个独立的、隔离的运行环境，允许在同一物理计算机上运行多个虚拟操作系统。每个虚拟机被视为一个独立的计算机，具有自己的操作系统和应用程序。
•	用途： 虚拟机的主要用途是在一台物理计算机上运行多个操作系统或应用程序，实现资源的有效共享和隔离。虚拟

 
在计算机系统中，虚拟内存是一种操作系统使用的技术，它允许程序访问一个比实际物理内存更大的地址空间。虚拟内存的一个重要功能是将不常用的数据从物理内存中移出，以便给其他数据或程序腾出空间。这允许执行比实际物理内存更大的程序，就像你描述的情况，一个12GB的程序在8GB的实际物理内存中执行。
以下是实现这种情况的一些关键概念：
1.	分页机制： 操作系统使用分页机制将程序和数据划分为固定大小的页面（通常为4KB）。这样，只有程序中当前需要的部分被加载到物理内存中。
2.	虚拟内存地址空间： 每个进程都有其自己的虚拟内存地址空间，通常是一个很大的地址范围，超过实际物理内存大小。这使得程序可以使用比物理内存更大的地址范围。
3.	页面置换： 当程序访问虚拟内存中的某个页面时，如果该页面不在物理内存中，操作系统将负责将其加载到物理内存中。如果物理内存已满，操作系统需要选择哪些页面从物理内存中移出，以便为新页面腾出空间。这个过程被称为页面置换。
4.	硬盘上的页面文件： 如果程序的虚拟内存中的某些部分不常用，它们可以被写入到硬盘上的页面文件中。当程序再次访问这些部分时，它们可以从页面文件中被重新加载到物理内存中。
在你描述的情况下，如果一个12GB的程序在8GB的实际物理内存中执行，操作系统可能会通过以下方式来实现：
•	将程序和数据划分为页面，并根据需要将页面加载到物理内存中。
•	对于不常用的页面，将其写入到硬盘上的页面文件中。
•	在程序执行过程中，根据需要进行页面置换，确保当前执行的部分在物理内存中。
需要注意的是，虽然虚拟内存提供了更大的地址空间，但当程序访问的页面不在物理内存中时，会引入一定的性能开销，因为需要从硬盘加载页面。因此，尽量避免过多的页面置换是设计高效程序的重要考虑因素


Demand paging
Thrashing

磁碟管理
Free space management
Allocation methods
RAID
RAID（Redundant Array of Independent Disks）是一种通过将多个硬盘驱动器组合在一起形成一个逻辑存储单元的技术，用于提高数据存储的性能、可靠性和/或容量。RAID系统可以通过将数据划分和复制到多个硬盘上，实现对数据的冗余和并行存储，从而提供更好的性能和容错能力。


 
•	读性能： RAID 0、RAID 5、RAID 6 和 RAID 10 在读性能方面通常较好，因为它们能够并行读取数据。
•	写性能： RAID 0 和 RAID 10 在写性能方面较好，而 RAID 5 和 RAID 6 的写性能相对较差，因为写操作需要计算奇偶校验信息。
冗余性：
•	RAID 1、RAID 5、RAID 6 和 RAID 10 提供了某种形式的冗余，允许在硬盘故障时保持数据可用。
•	RAID 0 没有冗余，一个硬盘故障将导致数据丢失。
容错能力：
•	RAID 1、RAID 5、RAID 6 和 RAID 10 具有一定的容错能力，能够在硬盘故障时继续提供服务。
•	RAID 0 没有容错能力，一个硬盘故障将导致数据不可用。
•	RAID 2： 位级条带化，使用海明码纠错，可通过错误检测和纠错来恢复数据，对磁盘的访问是并行的，但由于需要额外的硬件支持，实际中很少使用。
•	RAID 3： 字节级条带化，带奇偶校验，通过奇偶校验信息在单个硬盘故障时进行数据恢复，适用于大块数据的读操作。
•	RAID 4： 块级条带化，带奇偶校验，类似于 RAID 3，但是数据和奇偶校验信息存储在不同的硬盘上，适用于大块数据的读操作，对随机写操作性能较差。






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
deadlock
定義:是指两个或多个进程（线程）互相等待对方释放资源才能继续执行的状态。在死锁状态下，进程无法继续运行，导致系统停滞
特性:
1. mutual exclusion: 一次只有一個process可以使用資源
2. hold & wait: 一個process持有某些資源且等大其他process擁有的資源
3. no preemption: 資源只能被持有的process自己放棄，其他process無法搶占
4. circular wait: 環狀等待

解決方法:
Deadlock Prevention: 確保 deadlock 不會發生 => 4 個條件其中一個不成立
Mutual exclusion:
對 sharable resources 而言，Mutual exclusion 一定成立
而 nonsharable resources，因為可以同時讀取相同檔案，所以一定不會產生
但很困難讓他不成立

Hold and Wait:
process 必須保證一個行程在要求一項資源時，不可以佔用任何其它的資源
兩種可能策略
允許 process 在執行之初可先持有部分資源，一旦要申請新資源，則必須先釋放持有的全部資源，才可以提申請
除非 process 可以一次取得完成工作所需的全部資源，才允許 process 持有資源，否則不准持有任何資源
低資源利用率
可能會有 starvation

No preemption:
變成 preemption
process 可以搶奪 waiting process 所持有的 Resource
解決：採取類似”Aging”技術(將被搶奪的次數，列為提高優先權之依據)

Circular Wait:
確保循環式等候的條件不成立，我們對所有的資源型式強迫安排一個線性的順序
作法
給予每個 Resource 唯一的(unique)資源編號(ID)
規定 process 需依資源編號遞增的方式提出申請
優點:保證系統絕不會有死結存在

Deadlock Avoidance
當 process 提資源申請(Request)時，則 OS 需依據下列資訊：

系統目前可用的資源數量(Available)
各 process 對資源的最大需求量(max)
各 process 目前持有的資源量(allocation) 各系統還需多少資源(need) = max - allocation
執行 Banker’s Algorithm(內含 Safety Algorithm)判斷系統若核准後，是否處於 Safe state，若是，則核准申請，否則(處於 unsafe state)，則否決此次申請，Process 則等待依段時間後再重新申請

缺點:resource 可用率低、throughput 低


deadlock detection
偵測死結是否存在 若死結存在，則必須打破死結，恢復正常的機制

優點：resource utilization 較高，Throughput 高
缺點：cost 太高
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

作業系統型態
1. batch system
定義：　批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。这种采用批量处理作业技术的操作系统称为批处理操作系统；批处理操作系统不具有交互性，它是为了提高CPU的利用率而提出的一种操作系统

特色：　多道：在内存中同时存放多个作业，一个时刻只有一个作业运行，这些作业共享CPU和外部设备等资源。
成批：用户和他的作业之间没有交互性。用户自己不能干预自己的作业的运行，发现作业错误不能及时改正。
批处理系统的目的是提高系统吞吐量和资源的利用率。
多道处理系统的优点是由于系统资源为多个作业所共享，其工作方式是作业之间自动调度执行。并在运行过程中用户不干预自己的作业，从而大大提高了系统资源的利用率和作业吞吐量。其缺点是无交互性，用户一旦提交作业就失去了对其运行的控制能力，而且是批处理的，作业周转时间长，用户使用不方便
